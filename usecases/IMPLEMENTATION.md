# Implementation Guide

This guide is for developers implementing new use cases or extending existing ones. Use it when:

- **Adding a new use case** - Follow the directory structure, script patterns, and naming conventions
- **Troubleshooting deployments** - Reference the Terraform patterns and environment variables
- **Understanding the codebase** - See how existing use cases are structured and why

For a high-level overview of what each use case does and how they fit together, see the [architecture diagram in README.md](README.md#system-architecture).

## Directory Structure

Every use case follows this structure:

```
usecases/$name/
├── apps/
│   └── $appname/           # Go application
│       ├── main.go
│       ├── go.mod
│       ├── go.sum          # Generated by `go mod tidy`
│       ├── Dockerfile
│       └── .gitignore      # Ignore compiled binaries
├── infra/
│   └── terraform/
│       ├── 01-ecr/         # ECR repository (deployed first)
│       │   ├── main.tf
│       │   └── .gitignore
│       └── 02-app/         # Application infrastructure
│           ├── main.tf     # Provider, variables
│           ├── ecs.tf      # Security group, IAM, task definition
│           ├── *.tf        # Use-case specific resources
│           └── .gitignore
├── scripts/
│   ├── build.sh            # Build & push Docker image
│   ├── apply.sh            # Deploy all infrastructure
│   ├── destroy.sh          # Tear down infrastructure
│   ├── set-tf-vars.sh      # Generate TF_VAR_* exports
│   └── run-e2e.sh          # End-to-end test script
└── tests/
    └── $testname/          # Test runner application
        ├── main.go
        ├── go.mod
        ├── go.sum
        └── .gitignore
```

## Shared Infrastructure Dependency

Most use cases depend on shared infrastructure at `infra/terraform/`:
- ECS Cluster (`hello-fargate-cluster`)
- Output: `ecs_cluster_arn`

The E2E scripts automatically deploy shared infrastructure if not present.

**Exception:** `batchjobs` is self-contained (AWS Batch manages its own compute).

## Application Patterns by Use Case Type

### 1. One-off Tasks (`oneoff`)

See [oneoff/README.md](oneoff/README.md#implementation)

---

### 2. Background Jobs (`backgroundjobs`)

See [backgroundjobs/README.md](backgroundjobs/README.md#implementation)

---

### 3. Scheduled Jobs (`scheduledjobs`)

See [scheduledjobs/README.md](scheduledjobs/README.md#implementation)

---

### 4. Batch Jobs (`batchjobs`)

See [batchjobs/README.md](batchjobs/README.md#implementation)

---

## Common Terraform Patterns

### Reference Implementations

| Pattern | Reference File |
|---------|----------------|
| Variables & Provider | [oneoff/infra/terraform/02-app/main.tf](oneoff/infra/terraform/02-app/main.tf) |
| ECR Repository | [oneoff/infra/terraform/01-ecr/main.tf](oneoff/infra/terraform/01-ecr/main.tf) |
| ECS Base (SG, IAM, Task Def) | [oneoff/infra/terraform/02-app/ecs.tf](oneoff/infra/terraform/02-app/ecs.tf) |
| ECS Service + SQS | [backgroundjobs/infra/terraform/02-app/ecs.tf](backgroundjobs/infra/terraform/02-app/ecs.tf), [sqs.tf](backgroundjobs/infra/terraform/02-app/sqs.tf) |
| Step Functions + EventBridge | [scheduledjobs/infra/terraform/02-app/sfn.tf](scheduledjobs/infra/terraform/02-app/sfn.tf), [eventbridge.tf](scheduledjobs/infra/terraform/02-app/eventbridge.tf) |
| AWS Batch (Compute Env, Queue, Job Def) | [batchjobs/infra/terraform/02-app/batch.tf](batchjobs/infra/terraform/02-app/batch.tf), [iam.tf](batchjobs/infra/terraform/02-app/iam.tf) |

### Key Elements

Each `02-app/main.tf` includes:
- Terraform provider config (`hashicorp/aws ~> 6.0`)
- Required variables: `ecs_cluster_arn`, `image_uri`, `vpc_id`
- Optional variables: `task_cpu`, `task_memory`, `security_group_ids`

Each `02-app/ecs.tf` includes:
- `data "aws_subnets"` - Discovers subnets from VPC
- `aws_security_group` - Outbound-only for Fargate tasks
- `aws_cloudwatch_log_group` - 30-day retention
- `aws_iam_role` - Execution role (pulls images) + Task role (app permissions)

### .gitignore for Terraform

See [oneoff/infra/terraform/02-app/.gitignore](oneoff/infra/terraform/02-app/.gitignore)

---

## Script Patterns

### Reference Implementations

| Script | Reference File |
|--------|----------------|
| build.sh | [oneoff/scripts/build.sh](oneoff/scripts/build.sh) |
| set-tf-vars.sh | [oneoff/scripts/set-tf-vars.sh](oneoff/scripts/set-tf-vars.sh) |
| apply.sh | [oneoff/scripts/apply.sh](oneoff/scripts/apply.sh) |
| destroy.sh | [oneoff/scripts/destroy.sh](oneoff/scripts/destroy.sh) |
| run-e2e.sh | [oneoff/scripts/run-e2e.sh](oneoff/scripts/run-e2e.sh), [backgroundjobs/scripts/run-e2e.sh](backgroundjobs/scripts/run-e2e.sh) |

### Script Responsibilities

- **build.sh** - Build Docker image, authenticate to ECR, push image
- **set-tf-vars.sh** - Output `TF_VAR_*` exports for eval; fetches ECS cluster ARN from shared infra
- **apply.sh** - Deploy ECR → build image → deploy app infra → wait for IAM propagation
- **destroy.sh** - Tear down app infra → destroy ECR
- **run-e2e.sh** - Full test: check shared infra → apply → run test → cleanup (optional)

---

## Test Runner Best Practices

### Comprehensive Logging Before Failures

Always log diagnostic information before exiting with an error. This prevents the need to manually run AWS CLI commands for debugging.

Pattern:
1. Before any error exit, log all relevant state (task ARN, status, stopped reason, attachment details)
2. Include intermediate lookups (ENI IDs, subnet IDs, etc.) in logs
3. When querying AWS resources, log the full response details for debugging

Example from `backend/tests/sctest/main.go`:
```go
// Log task details for debugging
log.Printf("Task ARN: %s", *task.TaskArn)
log.Printf("Task Status: %s", *task.LastStatus)
if task.StoppedReason != nil {
    log.Printf("Stopped Reason: %s", *task.StoppedReason)
}

// Log all attachments for debugging
log.Printf("Task has %d attachment(s)", len(task.Attachments))
for i, attachment := range task.Attachments {
    log.Printf("  Attachment[%d]: Type=%s, Status=%s", i, *attachment.Type, *attachment.Status)
    for _, detail := range attachment.Details {
        if detail.Name != nil && detail.Value != nil {
            log.Printf("    %s = %s", *detail.Name, *detail.Value)
        }
    }
}
```

This pattern helped debug the ECS task public IP retrieval issue where ECS DescribeTasks attachment details didn't include `publicIPv4Address` even when `assign_public_ip = true`. The logs revealed the ENI ID, enabling fallback to EC2 DescribeNetworkInterfaces.

---

## Dockerfile Pattern

### Reference Implementation

See [oneoff/apps/task/Dockerfile](oneoff/apps/task/Dockerfile) or [backgroundjobs/apps/worker/Dockerfile](backgroundjobs/apps/worker/Dockerfile)

### Key Elements

- Multi-stage build with `golang:1.23-alpine`
- Static binary: `CGO_ENABLED=0 GOOS=linux`
- Final image: `alpine:latest` (minimal size)

---

## Environment Variables

Required for scripts:
- `AWS_ACCOUNT_ID` - AWS account ID
- `AWS_REGION` - AWS region (default: ap-northeast-1)
- `TF_VPC_ID` - VPC ID for networking

Optional:
- `TF_ECS_CLUSTER_ARN` - Override auto-discovery from shared infra
- `TF_TASK_CPU` - Override default CPU (256)
- `TF_TASK_MEMORY` - Override default memory (512)
- `TF_EXTRA_SG_IDS` - Additional security group IDs

---

## Naming Conventions

| Resource Type | Pattern |
|---------------|---------|
| ECR Repository | `hello-fargate-$NAME-app` |
| ECS Task Definition | `hello-fargate-$NAME-worker` or `hello-fargate-$NAME-app-task` |
| ECS Service | `hello-fargate-$NAME-service` |
| Security Group | `hello-fargate-$NAME-task-sg` |
| IAM Execution Role | `hello-fargate-$NAME-ecs-execution-role` |
| IAM Task Role | `hello-fargate-$NAME-ecs-task-role` |
| CloudWatch Log Group | `/ecs/hello-fargate-$NAME-task` |
| SQS Queue | `hello-fargate-$NAME-queue` |
| SQS DLQ | `hello-fargate-$NAME-dlq` |
| Step Function | `$prefix-main-workflow` |
| EventBridge Rule | `$prefix-schedule-rule` |
| Batch Compute Environment | `hello-fargate-$NAME-compute-env` |
| Batch Job Queue | `hello-fargate-$NAME-queue` |
| Batch Job Definition | `hello-fargate-$NAME-job-def` |

All resources should have a `Project` tag: `hello-fargate-$NAME`
