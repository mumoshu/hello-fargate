#!/bin/bash
set -e
set -o pipefail

# End-to-end test script for the Fargate Scheduled Workflow
# Usage: 
#   ./scripts/run-e2e.sh          # Runs all steps including cleanup
#   ./scripts/run-e2e.sh --no-cleanup # Runs all steps EXCEPT cleanup

# --- Configuration & Flags ---
PERFORM_CLEANUP=true
if [[ "$1" == "--no-cleanup" ]]; then
  PERFORM_CLEANUP=false
  echo "INFO: Cleanup step will be skipped."
fi

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
PROJECT_ROOT=$(realpath "$SCRIPT_DIR/..")
TF_ECR_DIR="$PROJECT_ROOT/terraform/01-ecr"
TF_APP_DIR="$PROJECT_ROOT/terraform/02-app"
TEST_RUNNER_DIR="$PROJECT_ROOT/test-runner"
IMAGE_TAG="latest" # Define image tag consistently

# --- Helper Functions ---
log() {
  echo "[E2E] INFO: $1"
}

error() {
  echo "[E2E] ERROR: $1" >&2
  exit 1
}

check_command() {
  if ! command -v "$1" &> /dev/null; then
    error "Command '$1' not found. Please install it and ensure it's in your PATH."
  fi
}

# --- Sanity Checks --- 
log "Running sanity checks..."
check_command docker
check_command go
check_command terraform
check_command jq
check_command aws

log "Checking for required environment variables (should be loaded via .env.local/direnv)..."
required_env_vars=("AWS_ACCOUNT_ID" "AWS_REGION" "TF_SUBNET_IDS")
missing_env_vars=()
for var in "${required_env_vars[@]}"; do
    if [[ -z "${!var}" ]]; then
        missing_env_vars+=("$var")
    fi
done
if [[ ${#missing_env_vars[@]} -ne 0 ]]; then
    echo "ERROR: Missing required environment variables:" >&2
    for var in "${missing_env_vars[@]}"; do
        echo "  - $var" >&2
    done
    error "Please set them (e.g., in .env.local) and ensure they are loaded into your environment."
fi
log "Environment checks passed."

# --- Step 1: Set Terraform Variables ---
log "Step 1: Setting Terraform environment variables..."
cd "$SCRIPT_DIR" # Ensure we are in the scripts directory
chmod +x set-tf-vars.sh
# Load the TF_VAR exports into the current shell
log "Running set-tf-vars.sh to generate TF_VARs..."
# These TF_VARs will be picked up by both terraform stages
eval $("./set-tf-vars.sh") || error "Failed to set Terraform variables."
log "Terraform variables set in environment."

# --- Step 2: Deploy ECR Repository ---
log "Step 2: Deploying ECR repository with Terraform..."
cd "$TF_ECR_DIR"

log "Running terraform init for ECR..."
terraform init -input=false || error "ECR Terraform init failed."

log "Running terraform apply for ECR..."
terraform apply -auto-approve -input=false || error "ECR Terraform apply failed."

log "Capturing ECR Repository URL output..."
ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url)
if [[ -z "$ECR_REPOSITORY_URL" ]]; then
  error "Failed to capture ecr_repository_url Terraform output from 01-ecr stage."
fi
log "ECR Repository URL: $ECR_REPOSITORY_URL"
log "ECR repository deployed successfully."

# --- Step 3: Build and Push Docker Image ---
log "Step 3: Building and pushing Docker image..."
cd "$SCRIPT_DIR" # Go back to script dir to run build.sh
# build.sh uses env vars (AWS_ACCOUNT_ID, AWS_REGION) and a hardcoded image name ('fargate-workflow-app')
# This MUST match the name generated by 01-ecr terraform (depends on 'prefix' variable)
# Default prefix is 'fargate-workflow', so default name 'fargate-workflow-app' matches.
chmod +x build.sh
./build.sh || error "Failed to build and push Docker image."
# Construct the final image URI using the Terraform output and tag
FINAL_IMAGE_URI="${ECR_REPOSITORY_URL}:${IMAGE_TAG}"
log "Docker image built and pushed successfully: $FINAL_IMAGE_URI"

# --- Step 4: Deploy Application Infrastructure --- 
log "Step 4: Deploying application infrastructure with Terraform..."
cd "$TF_APP_DIR"

log "Running terraform init for App..."
terraform init -input=false || error "App Terraform init failed."

log "Running terraform apply for App..."
# Pass the specific image URI generated in the previous step
terraform apply -auto-approve -input=false -var="image_uri=${FINAL_IMAGE_URI}" || error "App Terraform apply failed."

log "Capturing State Machine ARN output..."
STATE_MACHINE_ARN=$(terraform output -raw state_machine_arn)
if [[ -z "$STATE_MACHINE_ARN" ]]; then
  error "Failed to capture state_machine_arn Terraform output from 02-app stage."
fi
log "State Machine ARN: $STATE_MACHINE_ARN"
log "Application infrastructure deployed successfully."

# --- Step 5: Run Test Workflow --- 
log "Step 5: Building and running test workflow runner..."
cd "$TEST_RUNNER_DIR"

log "Building test-runner Go application..."
go mod tidy || log "Warning: go mod tidy failed, continuing anyway"
go build -o test-runner . || error "Failed to build test-runner."

# Function to run test and handle failures
run_test() {
    local mode=$1
    local mode_desc=$2
    
    log "Executing test-runner in $mode_desc mode..."
    # Capture output to potentially get execution ARN on failure
    RUNNER_OUTPUT_FILE=$(mktemp) 
    if ! ./test-runner --sm-arn="$STATE_MACHINE_ARN" --mode="$mode" | tee "$RUNNER_OUTPUT_FILE"; then
        log "Test runner failed in $mode_desc mode. Fetching execution history..."
        # Try to extract execution ARN from the runner's output
        EXECUTION_ARN=$(grep -E '(Execution started:|Found execution triggered by EventBridge:)' "$RUNNER_OUTPUT_FILE" | sed -n 's/.*: \(arn:.*\)/\1/p' | tail -1)
        rm "$RUNNER_OUTPUT_FILE"

        if [[ -n "$EXECUTION_ARN" ]]; then
            log "Fetching history for Execution ARN: $EXECUTION_ARN"
            # Get the last few events, especially looking for failure details
            aws stepfunctions get-execution-history --execution-arn "$EXECUTION_ARN" --reverse-order --max-items 10 --query 'events[*].{timestamp: timestamp, type: type, details: executionFailedEventDetails.error, cause: executionFailedEventDetails.cause}' --output json || log "Warning: Failed to fetch execution history from AWS."
            error "Test runner failed execution in $mode_desc mode. See execution history above for details."
        else
            log "Could not extract Execution ARN from test runner output."
            error "Test runner failed execution in $mode_desc mode. Check the AWS Step Functions console for details."
        fi
    else
        log "Test runner executed successfully in $mode_desc mode."
        rm "$RUNNER_OUTPUT_FILE"
    fi
}

# Test 1: Direct Step Functions execution
run_test "direct" "direct Step Functions"

# Test 2: EventBridge-triggered execution
log "Waiting 5 seconds before EventBridge test to ensure clean state..."
sleep 5
run_test "eventbridge" "EventBridge trigger"

# Test 3: Scheduled EventBridge trigger (optional, as it takes longer)
if [[ "${SKIP_SCHEDULED_TEST:-false}" != "true" ]]; then
    log "Waiting 5 seconds before scheduled trigger test..."
    sleep 5
    log "Note: Scheduled trigger test will create a temporary EventBridge rule and wait ~1.5 minutes"
    run_test "scheduled" "scheduled EventBridge trigger"
else
    log "Skipping scheduled trigger test (set SKIP_SCHEDULED_TEST=false to enable)"
fi

# --- Step 6: Cleanup --- 
if [[ "$PERFORM_CLEANUP" == true ]]; then
  log "Step 6: Cleaning up infrastructure with Terraform..."
  
  log "Destroying application infrastructure (02-app)..."
  cd "$TF_APP_DIR"
  # Re-evaluating vars might not be strictly needed for destroy, but doesn't hurt
  eval $("$SCRIPT_DIR/set-tf-vars.sh") || log "Warning: Failed to set Terraform variables for app destroy."
  terraform destroy -auto-approve -input=false || error "App Terraform destroy failed."
  log "Application infrastructure cleaned up successfully."

  log "Destroying ECR repository (01-ecr)..."
  cd "$TF_ECR_DIR"
  # Re-evaluating vars might not be strictly needed for destroy, but doesn't hurt
  eval $("$SCRIPT_DIR/set-tf-vars.sh") || log "Warning: Failed to set Terraform variables for ecr destroy."
  terraform destroy -auto-approve -input=false || error "ECR Terraform destroy failed."
  log "ECR repository cleaned up successfully."

else
  log "Step 6: Skipping cleanup as requested."
fi

log "E2E script completed successfully!"
exit 0 